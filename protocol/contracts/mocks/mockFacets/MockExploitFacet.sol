/*
 SPDX-License-Identifier: MIT
*/
pragma solidity ^0.8.20;

import "contracts/C.sol";
import "contracts/libraries/Token/LibTransfer.sol";
import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
import {Invariable} from "contracts/beanstalk/Invariable.sol";

/**
 * @author funderbrker
 * @title MockExploitFacet provides artificial vulnerabilities for testing
 **/

contract MockExploitFacet is Invariable {
    AppStorage internal s;

    /* State checking */

    function entitlementsMatchBalances() public view returns (bool) {
        address[] memory tokens = getTokensOfInterest();
        (
            uint256[] memory entitlements,
            uint256[] memory balances
        ) = getTokenEntitlementsAndBalances(tokens);

        for (uint256 i = 0; i < tokens.length; i++) {
            if (entitlements[i] != balances[i]) return false;
        }
        return true;
    }

    /* Internal token accounting exploits. */

    function exploitUserInternalTokenBalance() public fundsSafu {
        LibBalance.increaseInternalBalance(msg.sender, IERC20(C.UNRIPE_LP), 100_000_000);
    }

    function exploitUserSendTokenInternal() public fundsSafu {
        LibTransfer.sendToken(
            IERC20(C.BEAN_ETH_WELL),
            100_000_000_000,
            msg.sender,
            LibTransfer.To.INTERNAL
        );
    }

    function exploitFertilizer() public fundsSafu {
        s.sys.fert.fertilizedIndex += 100_000_000_000;
    }

    function exploitSop(address sopWell) public fundsSafu {
        s.sys.sop.plentyPerSopToken[C.WETH] = 100_000_000;
    }

    /* Token flow exploits. */

    function exploitTokenBalance() public noNetFlow {
        C.bean().transferFrom(msg.sender, address(this), 1_000_000);
    }

    function exploitUserSendTokenExternal0() public noNetFlow {
        LibTransfer.sendToken(IERC20(C.BEAN), 10_000_000_000, msg.sender, LibTransfer.To.EXTERNAL);
    }

    function exploitUserSendTokenExternal1() public noOutFlow {
        LibTransfer.sendToken(IERC20(C.BEAN), 10_000_000_000, msg.sender, LibTransfer.To.EXTERNAL);
    }

    function exploitUserDoubleSendTokenExternal() public oneOutFlow(C.BEAN) {
        LibTransfer.sendToken(IERC20(C.BEAN), 10_000_000_000, msg.sender, LibTransfer.To.EXTERNAL);
        LibTransfer.sendToken(IERC20(C.UNRIPE_LP), 10_000_000, msg.sender, LibTransfer.To.EXTERNAL);
    }

    function exploitBurnStalk0() public noNetFlow {
        s.sys.silo.stalk -= 1_000_000_000;
    }

    function exploitBurnStalk1() public noOutFlow {
        s.sys.silo.stalk -= 1_000_000_000;
    }

    /* Bean supply exploits. */

    function exploitBurnBeans() public noSupplyChange {
        C.bean().burn(100_000_000);
    }

    function exploitMintBeans0() public noSupplyChange {
        C.bean().mint(msg.sender, 100_000_000);
    }

    function exploitMintBeans1() public noSupplyChange {
        C.bean().mint(address(this), 100_000_000);
    }

    function exploitMintBeans2() public noSupplyIncrease {
        C.bean().mint(msg.sender, 100_000_000);
    }

    function exploitMintBeans3() public noSupplyIncrease {
        C.bean().mint(address(this), 100_000_000);
    }
}
